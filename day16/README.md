# Day 16

## Part 1
This seemed like a clear application of either Djikstra's algorithm or A\*. Well, at least I knew that was the textbook answer. I had never actually implemented either of these algorithms, so this was a good learning experience. I probably made a mistake by defining a dedicated `Node` class instead of just using a tuple, which would have automatically been hashable, allowed comparators, equality checks, etc. But adding those dunder methods was quite simple. Each node contained the position and orientation of the reindeer, and at each timestep the reindeer could go forward in the direction of its orientation or change its direction, incurring the appropriate cost. Then Dijkstra's algorithm could just run until the goal position was reached, with no attention paid to the final orientation.

## Part 2
I looked at this problem as requiring two new capabilities: first, the ability to extract the lowest cost path implied by running Dijkstra's algorithm and then second, the ability to handle degeneracy when multiple equivalent solutions were present. I started with the simpler problem of finding a single consistent path. For this, I kept track of the parent node every time a new node was visited. Then, I created a simple backtracking algorithm that would move backwards from the goal position, to its parent, to its parent, etc. until the initial node was reached, at which point we had traced out the entire path. After adding for accounting of the parent nodes and a simple backtracking algorithm, this was easily extended to handle multiple solutions. If a neighboring node was visited with a strictly lower cost than previously recorded, its parent node was updated to the current node. Otherwise, if a neighbor was found with the same cost, the current node was added to the current list of its parents. With this expanded accounting of allowing for a node to have multiple parents, the visited maze positions were easily extracted.

