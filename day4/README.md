# Day 4
This was probably the most enjoyable problem so far (even if that was only due to my curiosity to use an unorthodox and inefficient algorithm).

## Part 1
I pretty quickly identified two avenues to a solution here: one that is quick to implement and reasonably performant and one that is harder to implement and much slower to run. I was ready for a challenge, so I went with the less straightforward solution (but saved the other approach for Part 2). The idea itself is simple: we can enumerate over all of the valid lines through the puzzle, whether they are horizontal, vertical, or diagonal. Within each valid line, we can check how many times the key appears. It is worth mentioning that this could be a reasonable solution for certain (maybe contrived?) classes of this problem, such as when there are a very large number of keys, since the valid lines only need to be calculated once. Unlike the more straightforward solution, the number of traversals is constant with respect to the number of keys. To be clear, it is certainly not an efficient solution for this problem in particular. But it seemed like a fun challenge, so I proceeded anyway.

The tricky part here is identifying all of the valid diagonal lines without using a library like `numpy`. I treat the list of strings as a matrix that can be indexed by a row and column integer pair. Forming the valid diagonal lines becomes a task of identifying the appropriate list of these pairs of indices. And unlike a standard matrix problem, we are searching not just for diagonals from the upper left to the lower right but also diagonals from the bottom left to the upper right. I created a method that extracts the list of strings corresponding to the diagonals that start in the upper left of the matrix. Instead of doing additional work to implement a similar method to extract the list of strings for the diagonals that start in the bottom left, I used a bit of a symmetry trick. We can horizontally mirror our character matrix by reversing each of the strings in our list. The diagonals starting in the upper left of this transformed matrix correspond to the diagonals starting in the lower left of the original matrix, so I could simply reuse the existing method to extract the other diagonals that I could not produce directly.

Once all of the valid line are identified, counting the matches is trivial.

## Part 2
Here I used the more obvious solution: I searched for the indices containing the center character of the key, and then checked which of these indices produced valid matches. This part was quite straightforward, so I was glad I went a little wild with the first part.
